/**
 * Cesium - https://github.com/AnalyticalGraphicsInc/cesium
 *
 * Copyright 2011-2020 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md for full licensing details.
 */
define(["exports","./when-4ca4e419","./Math-c0afb7aa","./Cartesian2-0cd32dae","./Transforms-1f147cce","./PolylineVolumeGeometryLibrary-85267466","./PolylinePipeline-1211a424"],function(a,s,O,R,u,V,Q){"use strict";var e={},U=new R.Cartesian3,d=new R.Cartesian3,p=new R.Cartesian3,m=new R.Cartesian3,G=[new R.Cartesian3,new R.Cartesian3],I=new R.Cartesian3,q=new R.Cartesian3,j=new R.Cartesian3,k=new R.Cartesian3,F=new R.Cartesian3,H=new R.Cartesian3,J=new R.Cartesian3,K=new R.Cartesian3,W=new R.Cartesian3,X=new R.Cartesian3,c=new u.Quaternion,g=new u.Matrix3;function Y(a,e,r,n,t){var i=R.Cartesian3.angleBetween(R.Cartesian3.subtract(e,a,U),R.Cartesian3.subtract(r,a,d)),s=n===V.CornerType.BEVELED?1:Math.ceil(i/O.CesiumMath.toRadians(5))+1,n=3*s,o=new Array(n);o[n-3]=r.x,o[n-2]=r.y,o[n-1]=r.z;var C=t?u.Matrix3.fromQuaternion(u.Quaternion.fromAxisAngle(R.Cartesian3.negate(a,U),i/s,c),g):u.Matrix3.fromQuaternion(u.Quaternion.fromAxisAngle(a,i/s,c),g),l=0;e=R.Cartesian3.clone(e,U);for(var y=0;y<s;y++)e=u.Matrix3.multiplyByVector(C,e,e),o[l++]=e.x,o[l++]=e.y,o[l++]=e.z;return o}function Z(a,e,r,n){var t=U;return[(t=(n||(e=R.Cartesian3.negate(e,e)),R.Cartesian3.add(a,e,t))).x,t.y,t.z,r.x,r.y,r.z]}function $(a,e,r,n){for(var t=new Array(a.length),i=new Array(a.length),s=R.Cartesian3.multiplyByScalar(e,r,U),o=R.Cartesian3.negate(s,d),C=0,l=a.length-1,y=0;y<a.length;y+=3){var u=R.Cartesian3.fromArray(a,y,p),c=R.Cartesian3.add(u,o,m);t[C++]=c.x,t[C++]=c.y,t[C++]=c.z;u=R.Cartesian3.add(u,s,m);i[l--]=u.z,i[l--]=u.y,i[l--]=u.x}return n.push(t,i),n}e.addAttribute=function(a,e,r,n){var t=e.x,i=e.y,e=e.z;s.defined(r)&&(a[r]=t,a[r+1]=i,a[r+2]=e),s.defined(n)&&(a[n]=e,a[n-1]=i,a[n-2]=t)};var _=new R.Cartesian3,aa=new R.Cartesian3;e.computePositions=function(a){var e=a.granularity,r=a.positions,n=a.ellipsoid,t=a.width/2,i=a.cornerType,s=a.saveAttributes,o=I,C=q,l=j,y=k,u=F,c=H,d=J,p=K,m=W,g=X,h=[],f=s?[]:void 0,w=s?[]:void 0,z=r[0],x=r[1],C=R.Cartesian3.normalize(R.Cartesian3.subtract(x,z,C),C),o=n.geodeticSurfaceNormal(z,o),y=R.Cartesian3.normalize(R.Cartesian3.cross(o,C,y),y);s&&(f.push(y.x,y.y,y.z),w.push(o.x,o.y,o.z));for(var P,A,B,v,E,S,b,d=R.Cartesian3.clone(z,d),z=x,l=R.Cartesian3.negate(C,l),D=[],M=r.length,T=1;T<M-1;T++){o=n.geodeticSurfaceNormal(z,o),x=r[T+1],C=R.Cartesian3.normalize(R.Cartesian3.subtract(x,z,C),C),u=R.Cartesian3.normalize(R.Cartesian3.add(C,l,u),u);var N=R.Cartesian3.multiplyByScalar(o,R.Cartesian3.dot(C,o),_);R.Cartesian3.subtract(C,N,N),R.Cartesian3.normalize(N,N);var L=R.Cartesian3.multiplyByScalar(o,R.Cartesian3.dot(l,o),aa);R.Cartesian3.subtract(l,L,L),R.Cartesian3.normalize(L,L),O.CesiumMath.equalsEpsilon(Math.abs(R.Cartesian3.dot(N,L)),1,O.CesiumMath.EPSILON7)||(u=R.Cartesian3.cross(u,o,u),u=R.Cartesian3.cross(o,u,u),u=R.Cartesian3.normalize(u,u),N=t/Math.max(.25,R.Cartesian3.magnitude(R.Cartesian3.cross(u,l,U))),L=V.PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(C,l,z,n),u=R.Cartesian3.multiplyByScalar(u,N,u),L?(p=R.Cartesian3.add(z,u,p),g=R.Cartesian3.add(p,R.Cartesian3.multiplyByScalar(y,t,g),g),m=R.Cartesian3.add(p,R.Cartesian3.multiplyByScalar(y,2*t,m),m),G[0]=R.Cartesian3.clone(d,G[0]),G[1]=R.Cartesian3.clone(g,G[1]),h=$(Q.PolylinePipeline.generateArc({positions:G,granularity:e,ellipsoid:n}),y,t,h),s&&(f.push(y.x,y.y,y.z),w.push(o.x,o.y,o.z)),c=R.Cartesian3.clone(m,c),y=R.Cartesian3.normalize(R.Cartesian3.cross(o,C,y),y),m=R.Cartesian3.add(p,R.Cartesian3.multiplyByScalar(y,2*t,m),m),d=R.Cartesian3.add(p,R.Cartesian3.multiplyByScalar(y,t,d),d),i===V.CornerType.ROUNDED||i===V.CornerType.BEVELED?D.push({leftPositions:Y(p,c,m,i,L)}):D.push({leftPositions:Z(z,R.Cartesian3.negate(u,u),m,L)})):(m=R.Cartesian3.add(z,u,m),g=R.Cartesian3.add(m,R.Cartesian3.negate(R.Cartesian3.multiplyByScalar(y,t,g),g),g),p=R.Cartesian3.add(m,R.Cartesian3.negate(R.Cartesian3.multiplyByScalar(y,2*t,p),p),p),G[0]=R.Cartesian3.clone(d,G[0]),G[1]=R.Cartesian3.clone(g,G[1]),h=$(Q.PolylinePipeline.generateArc({positions:G,granularity:e,ellipsoid:n}),y,t,h),s&&(f.push(y.x,y.y,y.z),w.push(o.x,o.y,o.z)),c=R.Cartesian3.clone(p,c),y=R.Cartesian3.normalize(R.Cartesian3.cross(o,C,y),y),p=R.Cartesian3.add(m,R.Cartesian3.negate(R.Cartesian3.multiplyByScalar(y,2*t,p),p),p),d=R.Cartesian3.add(m,R.Cartesian3.negate(R.Cartesian3.multiplyByScalar(y,t,d),d),d),i===V.CornerType.ROUNDED||i===V.CornerType.BEVELED?D.push({rightPositions:Y(m,c,p,i,L)}):D.push({rightPositions:Z(z,u,p,L)})),l=R.Cartesian3.negate(C,l)),z=x}return o=n.geodeticSurfaceNormal(z,o),G[0]=R.Cartesian3.clone(d,G[0]),G[1]=R.Cartesian3.clone(z,G[1]),h=$(Q.PolylinePipeline.generateArc({positions:G,granularity:e,ellipsoid:n}),y,t,h),s&&(f.push(y.x,y.y,y.z),w.push(o.x,o.y,o.z)),i===V.CornerType.ROUNDED&&(A=I,B=q,v=j,E=(P=h)[1],B=R.Cartesian3.fromArray(P[1],E.length-3,B),v=R.Cartesian3.fromArray(P[0],0,v),S=Y(A=R.Cartesian3.midpoint(B,v,A),B,v,V.CornerType.ROUNDED,!1),b=P.length-1,a=P[b-1],E=P[b],B=R.Cartesian3.fromArray(a,a.length-3,B),v=R.Cartesian3.fromArray(E,0,v),v=[S,Y(A=R.Cartesian3.midpoint(B,v,A),B,v,V.CornerType.ROUNDED,!1)]),{positions:h,corners:D,lefts:f,normals:w,endPositions:v}},a.CorridorGeometryLibrary=e});
