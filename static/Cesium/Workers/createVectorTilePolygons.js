/**
 * Cesium - https://github.com/AnalyticalGraphicsInc/cesium
 *
 * Copyright 2011-2020 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md for full licensing details.
 */
define(["./when-4ca4e419","./Check-430b3551","./Math-c0afb7aa","./Cartesian2-0cd32dae","./defineProperties-24e785e9","./Transforms-1f147cce","./RuntimeError-443472b0","./WebGLConstants-2ddfa2f9","./AttributeCompression-424ccc06","./IndexDatatype-a78bfe07","./IntersectionTests-9618f995","./Plane-6d029ea4","./createTaskProcessorWorker","./EllipsoidTangentPlane-6e29c6f6","./OrientedBoundingBox-963ed09f","./Color-37005ea1"],function(ye,e,Ie,me,a,r,n,t,we,ve,i,o,s,f,xe,Ae){"use strict";var Ee=new me.Cartesian3,Ne=new me.Ellipsoid,Te=new me.Rectangle,ke={min:void 0,max:void 0,indexBytesPerElement:void 0};function Be(e,a,r){var n=a.length,t=2+n*xe.OrientedBoundingBox.packedLength+1+function(e){for(var a=e.length,r=0,n=0;n<a;++n)r+=Ae.Color.packedLength+3+e[n].batchIds.length;return r}(r),i=new Float64Array(t),o=0;i[o++]=e,i[o++]=n;for(var s=0;s<n;++s)xe.OrientedBoundingBox.pack(a[s],i,o),o+=xe.OrientedBoundingBox.packedLength;var f=r.length;i[o++]=f;for(var d=0;d<f;++d){var c=r[d];Ae.Color.pack(c.color,i,o),o+=Ae.Color.packedLength,i[o++]=c.offset,i[o++]=c.count;var u=c.batchIds,h=u.length;i[o++]=h;for(var l=0;l<h;++l)i[o++]=u[l]}return i}var Le=new me.Cartesian3,Oe=new me.Cartesian3,Pe=new me.Cartesian3,Ue=new me.Cartesian3,Fe=new me.Cartesian3,Se=new me.Cartographic,Re=new me.Rectangle;return s(function(e,a){var r;t=e.packedBuffer,r=new Float64Array(t),t=0,ke.indexBytesPerElement=r[t++],ke.min=r[t++],ke.max=r[t++],me.Cartesian3.unpack(r,3,Ee),t+=me.Cartesian3.packedLength,me.Ellipsoid.unpack(r,t,Ne),t+=me.Ellipsoid.packedLength,me.Rectangle.unpack(r,t,Te);var n=new(2===ke.indexBytesPerElement?Uint16Array:Uint32Array)(e.indices),t=new Uint16Array(e.positions),i=new Uint32Array(e.counts),o=new Uint32Array(e.indexCounts),s=new Uint32Array(e.batchIds),f=new Uint32Array(e.batchTableColors),d=new Array(i.length),c=Ee,u=Ne,h=Te,l=ke.min,g=ke.max,p=e.minimumHeights,b=e.maximumHeights;ye.defined(p)&&ye.defined(b)&&(p=new Float32Array(p),b=new Float32Array(b));var C=t.length/2,y=t.subarray(0,C),I=t.subarray(C,2*C);we.AttributeCompression.zigZagDeltaDecode(y,I);for(var m=new Float32Array(3*C),w=0;w<C;++w){var v=y[w],x=I[w],v=Ie.CesiumMath.lerp(h.west,h.east,v/32767),x=Ie.CesiumMath.lerp(h.south,h.north,x/32767),x=me.Cartographic.fromRadians(v,x,0,Se),x=u.cartographicToCartesian(x,Le);me.Cartesian3.pack(x,m,3*w)}var A=i.length,E=new Array(A),N=new Array(A),T=0,k=0;for(w=0;w<A;++w)E[w]=T,N[w]=k,T+=i[w],k+=o[w];var B=new Float32Array(3*C*2),L=new Uint16Array(2*C),O=new Uint32Array(N.length),P=new Uint32Array(o.length),U=[],F={};for(w=0;w<A;++w)_=f[w],ye.defined(F[_])?(F[_].positionLength+=i[w],F[_].indexLength+=o[w],F[_].batchIds.push(w)):F[_]={positionLength:i[w],indexLength:o[w],offset:0,indexOffset:0,batchIds:[w]};var S,R=0,D=0;for(_ in F)F.hasOwnProperty(_)&&((G=F[_]).offset=R,G.indexOffset=D,R+=2*G.positionLength,D+=S=2*G.indexLength+6*G.positionLength,G.indexLength=S);var M=[];for(_ in F)F.hasOwnProperty(_)&&(G=F[_],M.push({color:Ae.Color.fromRgba(parseInt(_)),offset:G.indexOffset,count:G.indexLength,batchIds:G.batchIds}));for(w=0;w<A;++w){var _,G,Y=(G=F[_=f[w]]).offset,V=3*Y,H=Y,W=E[w],z=i[w],Z=s[w],j=l,q=g;ye.defined(p)&&ye.defined(b)&&(j=p[w],q=b[w]);for(var J=Number.POSITIVE_INFINITY,K=Number.NEGATIVE_INFINITY,Q=Number.POSITIVE_INFINITY,X=Number.NEGATIVE_INFINITY,$=0;$<z;++$){var ee=me.Cartesian3.unpack(m,3*W+3*$,Le);u.scaleToGeodeticSurface(ee,ee);var ae=u.cartesianToCartographic(ee,Se),re=ae.latitude,ne=ae.longitude,J=Math.min(re,J),K=Math.max(re,K),Q=Math.min(ne,Q),X=Math.max(ne,X),ae=u.geodeticSurfaceNormal(ee,Oe),re=me.Cartesian3.multiplyByScalar(ae,j,Pe),ne=me.Cartesian3.add(ee,re,Ue),re=me.Cartesian3.multiplyByScalar(ae,q,re),re=me.Cartesian3.add(ee,re,Fe);me.Cartesian3.subtract(re,c,re),me.Cartesian3.subtract(ne,c,ne),me.Cartesian3.pack(re,B,V),me.Cartesian3.pack(ne,B,V+3),L[H]=Z,L[H+1]=Z,V+=6,H+=2}(h=Re).west=Q,h.east=X,h.south=J,h.north=K,d[w]=xe.OrientedBoundingBox.fromRectangle(h,l,g,u);var te=G.indexOffset,ie=N[w],oe=o[w];for(O[w]=te,$=0;$<oe;$+=3){var se=n[ie+$]-W,fe=n[ie+$+1]-W,de=n[ie+$+2]-W;U[te++]=2*se+Y,U[te++]=2*fe+Y,U[te++]=2*de+Y,U[te++]=2*de+1+Y,U[te++]=2*fe+1+Y,U[te++]=2*se+1+Y}for($=0;$<z;++$){var ce=$,ue=($+1)%z;U[te++]=2*ce+1+Y,U[te++]=2*ue+Y,U[te++]=2*ce+Y,U[te++]=2*ce+1+Y,U[te++]=2*ue+1+Y,U[te++]=2*ue+Y}G.offset+=2*z,G.indexOffset=te,P[w]=te-O[w]}for(var U=ve.IndexDatatype.createTypedArray(B.length/3,U),he=M.length,le=0;le<he;++le){for(var ge=M[le].batchIds,pe=0,be=ge.length,Ce=0;Ce<be;++Ce)pe+=P[ge[Ce]];M[le].count=pe}return t=Be(2===U.BYTES_PER_ELEMENT?ve.IndexDatatype.UNSIGNED_SHORT:ve.IndexDatatype.UNSIGNED_INT,d,M),a.push(B.buffer,U.buffer,O.buffer,P.buffer,L.buffer,t.buffer),{positions:B.buffer,indices:U.buffer,indexOffsets:O.buffer,indexCounts:P.buffer,batchIds:L.buffer,packedBuffer:t.buffer}})});
